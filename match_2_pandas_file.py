import numpy as np
import pandas as pd
import argparse


def take_first(elem):
    # for list sorting
    return elem[0]


def extract_average_locations_from_csv_file(csv_file_path='pc0_tags_location.csv'):
    df = pd.read_csv(csv_file_path)
    df['tag_id'] = df['tag_id'].astype("int")
    mid_pc_tag_locations = []  # [tag_id,tag_x,tag_y,tag_z]

    all_tag_ids = df['tag_id'].unique()

    for i in range(len(all_tag_ids)):
        mid_df = df.query('tag_id==' + str(all_tag_ids[i]))

        mean_val = mid_df.mean()
        mid_pc_tag_locations.append(
            [int(mean_val['tag_id']), mean_val['tag_x'], mean_val['tag_y'], mean_val['tag_z'], 1])
    mid_pc_tag_locations.sort(key=take_first)  # sort by tag_id
    # print(csv_file_path, ' is \n', np.asarray(mid_pc_tag_locations), 'debug')
    return np.asarray(mid_pc_tag_locations)  # [id, average_x, average_y, average_z]


def rigid_transform_3D(B, A):
    assert len(A) == len(B)

    N = A.shape[0]  # total points
    centroid_A = np.mean(A, axis=0)
    centroid_B = np.mean(B, axis=0)

    # centre the points
    AA = A - np.tile(centroid_A, (N, 1))
    BB = B - np.tile(centroid_B, (N, 1))

    H = np.matmul(np.transpose(AA), BB)
    U, S, Vt = np.linalg.svd(H)
    R = np.matmul(Vt.T, U.T)

    # special reflection case
    if np.linalg.det(R) < 0:
        print("Reflection detected")
        Vt[2, :] *= -1
        R = np.matmul(Vt.T, U.T)

    t = -np.matmul(R, centroid_A) + centroid_B
    # err = B - np.matmul(A,R.T) - t.reshape([1, 3])
    R, t = R[:3, :3], t[:3]
    print('R:\n', R, '\nt:\n', t)
    return R, t


def get_transform_matrix(pc1_tag_global_location='pc0_tags_location.csv',
                         pc2_tag_global_location='pc0_tags_location.csv'):
    pc1_tag_locations = extract_average_locations_from_csv_file(pc1_tag_global_location)
    pc2_tag_locations = extract_average_locations_from_csv_file(pc2_tag_global_location)
    # print(pc1_tag_locations)
    pc1_tag_locations = np.array(pc1_tag_locations[:, 1:])
    pc2_tag_locations = np.array(pc2_tag_locations[:, 1:])
    R, t = rigid_transform_3D(pc1_tag_locations, pc2_tag_locations)
    return R, t  # np.ndarray 4*4;  follow pc1 = T21 * pc2


def transform_pc2_to_pc1(pc2_file_path='pc0.pts', pc2_save_path='modified_pc2.pts',
                         pc1_tag_csv_path='pc0_tags_location.csv',
                         pc2_tag_csv_path='pc0_tags_location.csv'):
    R, t = get_transform_matrix(pc1_tag_csv_path, pc2_tag_csv_path)
    pc2_file_path = pc2_file_path
    pc2 = pd.read_csv(pc2_file_path, sep=' ')
    pc2.columns = ['x', 'y', 'z', 'intensity', 'r', 'g', 'b']
    pc2['intensity'] = 1.0

    # pc21 = T.dot(np.array(pc2).T[:4, ...]).T
    print('verify shapes', np.array(pc2)[..., :3].shape, R.T.shape)
    pc21 = np.matmul(np.array(pc2)[..., :3], R.T) + t.reshape([1, 3])
    print('pc21.shape', pc21.shape)

    pc2['x'] = pc21[..., 0]
    pc2['y'] = pc21[..., 1]
    pc2['z'] = pc21[..., 2]

    pc2.to_csv(pc2_save_path, sep=' ', index=False)


if __name__ == "__main__":
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument("--pc2_file_path", default='pc1.pts',
                            help="color point clouds, a pts file generated by pts_generate.py")
    arg_parser.add_argument("--pc2_save_path", default='modified_pc1.pts',
                            help="saving path of modified pc2")
    arg_parser.add_argument("--pc1_tag_csv_path", default='pc0_tags_location.csv',
                            help="global coordinate location of tags in pc1, a csv file generated by match.py")
    arg_parser.add_argument("--pc2_tag_csv_path", default='pc1_tags_location.csv',
                            help="global coordinate location of tags in pc2, a csv file generated by match.py")
    args = arg_parser.parse_args()
    transform_pc2_to_pc1(args.pc2_file_path, args.pc2_save_path, args.pc1_tag_csv_path, args.pc2_tag_csv_path)

# pc1.pts modified_pc1.pts pc0_tags_location.csv pc1_tags_location.csv
